{
  "author": {
    "name": "Andris Reinman",
    "email": "andris@node.ee"
  },
  "name": "pem",
  "description": "Create private keys and certificates with node.js",
  "version": "1.4.1",
  "repository": {
    "type": "git",
    "url": "git://github.com/andris9/pem.git"
  },
  "main": "lib/pem",
  "scripts": {
    "test": "nodeunit test"
  },
  "dependencies": {},
  "devDependencies": {
    "nodeunit": "*"
  },
  "optionalDependencies": {},
  "engines": {
    "node": "*"
  },
  "readme": "pem\n===\n\nCreate private keys and certificates with node.js\n\n[![Build Status](https://secure.travis-ci.org/andris9/pem.png)](http://travis-ci.org/andris9/pem)\n\n## Installation\n\nInstall with npm\n\n    npm install pem\n\n## Examples\n\nHere are some examples for creating an SSL key/cert on the fly, and running an HTTPS server on port 443.  443 is the standard HTTPS port, but requires root permissions on most systems.  To get around this, you could use a higher port number, like 4300, and use https://localhost:4300 to access your server.\n\n### Basic https\n```javascript\nvar https = require('https'),\n    pem = require('pem');\n\npem.createCertificate({days:1, selfSigned:true}, function(err, keys){\n    https.createServer({key: keys.serviceKey, cert: keys.certificate}, function(req, res){\n        res.end(\"o hai!\")\n    }).listen(443);\n});\n```\n\n###  Express\n```javascript\nvar https = require('https'),\n    pem = require('pem'),\n    express = require('express');\n\npem.createCertificate({days:1, selfSigned:true}, function(err, keys){\n  var app = express();\n  \n  app.get('/',  requireAuth, function(req, res){\n    res.send(\"o hai!\");\n  });\n  \n  https.createServer({key: keys.serviceKey, cert: keys.certificate}, app).listen(443);\n});\n```\n\n## API\n\n### Create a private key\n\nUse `createPrivateKey` for creating private keys\n\n    pem.createPrivateKey(keyBitsize, callback)\n\nWhere\n\n  * **keyBitsize** is an optional size of the key, defaults to 2048 (bit)\n  * **callback** is a callback function with an error object and `{key}`\n\n### Create a Certificate Signing Request\n\nUse `createCSR` for creating private keys\n\n    pem.createCSR(options, callback)\n\nWhere\n\n  * **options** is an optional options object\n  * **callback** is a callback function with an error object and `{csr, clientKey}`\n\nPossible options are the following\n\n  * **clientKey** is an optional client key to use\n  * **keyBitsize** - if `clientKey` is undefined, bit size to use for generating a new key (defaults to 2048)\n  * **hash** is a hash function to use (either `md5`, `sha1` or `sha256`, defaults to `sha256`)\n  * **country** is a CSR country field\n  * **state** is a CSR state field\n  * **locality** is a CSR locality field\n  * **organization** is a CSR organization field\n  * **organizationUnit** is a CSR organizational unit field\n  * **commonName** is a CSR common name field (defaults to `localhost`)\n  * **altNames** is a list of subjectAltNames in the subjectAltName field (optional)\n  * **emailAddress** is a CSR email address field\n\n### Create a certificate\n\nUse `createCertificate` for creating private keys\n\n    pem.createCertificate(options, callback)\n\nWhere\n\n  * **options** is an optional options object\n  * **callback** is a callback function with an error object and `{certificate, csr, clientKey, serviceKey}`\n\nPossible options include all the options for `createCSR` - in case `csr` parameter is not defined and a new\nCSR needs to be generated.\n\nIn addition, possible options are the following\n\n  * **serviceKey** is a private key for signing the certificate, if not defined a new one is generated\n  * **selfSigned** - if set to true and `serviceKey` is not defined, use `clientKey` for signing\n  * **csr** is a CSR for the certificate, if not defined a new one is generated\n  * **days** is the certificate expire time in days\n\n### Export a public key\n\nUse `getPublicKey` for exporting a public key from a private key, CSR or certificate\n\n    pem.getPublicKey(certificate, callback)\n\nWhere\n\n  * **certificate** is a PEM encoded private key, CSR or certificate\n  * **callback** is a callback function with an error object and `{publicKey}`\n\n### Read certificate info\n\nUse `readCertificateInfo` for reading subject data from a certificate or a CSR\n\n    pem.readCertificateInfo(certificate, callback)\n\nWhere\n\n  * **certificate** is a PEM encoded CSR or a certificate\n  * **callback** is a callback function with an error object and `{country, state, locality, organization, organizationUnit, commonName, emailAddress, validity{start, end}, san{dns, ip}? }`\n  \n? *san* is only present if the CSR or certificate has SAN entries.\n\n### Get fingerprint\n\nUse `getFingerprint` to get the SHA1 fingerprint for a certificate\n\n    pem.getFingerprint(certificate, callback)\n\nWhere\n\n  * **certificate** is a PEM encoded certificate\n  * **callback** is a callback function with an error object and `{fingerprint}`\n\n### Get modulus\n\nUse `getModulus` to get the modulus for a certificate, a CSR or a private key. Modulus can be useful to check that a Private Key Matches a Certificate\n\n    pem.getModulus(certificate, callback)\n\nWhere\n\n  * **certificate** is a PEM encoded certificate, CSR or private key\n  * **callback** is a callback function with an error object and `{modulus}`\n\n## License\n\n**MIT**\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/andris9/pem/issues"
  },
  "homepage": "https://github.com/andris9/pem",
  "_id": "pem@1.4.1",
  "_shasum": "9bac15dbf86de4e742d3c30d93bb154d80335b45",
  "_from": "pem@~1.4.1",
  "_resolved": "https://registry.npmjs.org/pem/-/pem-1.4.1.tgz"
}
